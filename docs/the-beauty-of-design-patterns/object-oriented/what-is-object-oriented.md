# 面向对象是什么

## 什么是面向对象编程

面向对象对象编程是一种编程范式（风格）：
- 以类或对象作为组织代码的基本单元；
- 将封装、抽象、继承和多态作为代码设计和实现的基础。

## 什么语言是面向对象的语言

相对应的，面向对象编程语法需要：
- 支持类或者对象的语法机制；
- 有语法机制能方便的实现面向对象的四大特性封装、抽象、继承和多态。

### 怎么判断是否是面向对象语言

1. 如果不按照严格的定义，大部分语言都是面向对象编程语言。
例如 JS 不支持封装和继承，按照严格意义它不算面向对象编程语言，但是某种意义上他也是面向对象的编程语言。
2. 从面向对象编程的字面上，最简单、最原始的方式就是将对象或类作为代码组织的基本单元，来进行编程的一种编程方式（风格）。
是否有现成语法支持面向对象的四大特性、是否对四大特性有所取舍，可以不作为标准。

### 面向对象编程和面向对象编程语言之间的关系

1. 面向对象编程一般使用面向对象编程语言来进行，但是不用面向对象编程语言照样可以面向对象编程
2. 反过来，我们使用面向对象编程语言，写出来的代码也不一定是面向对象风格，而是面向过程风格。

## 四大特性封装、抽象、继承、多态是什么解决了什么问题

理解面向对象，关键是理解其四大特性：封装、抽象、继承、多态。对于这四大特性，光理解它们的定义是不够的，还需要知道每个特性的意义和目的，以及解决了什么问题。

### 封装

#### 定义

- 封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部**仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据**。
- 封装不是拒绝访问，而是限制访问。单纯的属性私有化不能称为封装

```typescript
interface personOptions {
  name: string;
  height: number;
  age: number;
}

class Person {
  public name: string;
  public height: number;
  private age: number;

  constructor(options: personOptions) {
    const { name, height, age} = options;
    this.name = name;
    this.height = height;
    this.age = age;
  }

  getName() {
    return this.name;
  }

  getHeight() {
    return this.height;
  }

  getAge() {
    return this.age;
  }

  setHeight(height: number) {
    this.height = height;
  }
}

const person = new Person({
  name: 'John',
  height: 175,
  age: 20
})

person.age; // Property 'age' is private and only accessible within class 'Person'.
```

对 `age` 属性的访问进行了限制，只能通过 getAge 进行访问。封装这个特性，需要编程语言提供一定的语法机制来支持，这个语法支持就是访**问权限控制**。

#### 意义和解决的问题

1. 提升可维护性：如果不对属性访问做限制，那任何代码都可以访问、修改属性，虽然更灵活，但是也更不可控，修改的逻辑散落在各个地方，最后不知道哪里改了数据
2. 提升易用性：如果直接把属性暴露给调用者，调用者想修改这些属性，就需要对业务细节有足够的理解，这也是一种负担。将属性封装起来，暴露必要的方法给调用方，这样就不用关注太多细节了。

### 抽象

#### 定义

- 封装主要讲的是如何隐藏信息、保护数据；
- 而抽象讲的是如何隐藏方法的具体实现，让调用者只需要**关心提供了哪些功能**，并不需要知道这些功能是如何实现的。

使用编程语言中的接口类 `interface` 就可以实现抽象这一特性

```ts
interface Pingable {
  ping(): void;
}
 
class Sonar implements Pingable {
  ping() {
    console.log("ping!");
  }
}
```

调用者在调用 `Pingable` 就可以了解它提供了那些方法，不需要去了解具体实现逻辑。但是不使用 `Pingable`，`Sonar` 类本身也满足抽象特性，因为类的方法是通过“函数”实现的，通过函数实现具体逻辑，这本身就是一种抽象。

#### 意义和解决的问题

- 过滤掉不必要关注的信息。人脑能承受的信息复杂程度是有限的，通过抽象，可以帮助我们过滤掉需要非必要的信息
- 提升可维护性、可扩展性。换个角度，我们在定义方法的时候也要有抽象思维，不要在方法定义中暴露太多细节（但是也不能太宽泛），这样后面如果我们需要修改方法实现不用去修改定义。`getPictureUrl` 就比 `getAliyunPictureUrl` 好。
- 抽象作为一种宽泛的设计思想，对代码设计起到重要的指导作用。很多设计原则都体现这种原则：开闭原则、代码解耦

### 继承

#### 定义

- 继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。
- 从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

```ts
class Person {
  public name: string;
  public height: number;
  private age: number;

  constructor(options: personOptions) {
    const { name, height, age} = options;
    this.name = name;
    this.height = height;
    this.age = age;
  }
}

class Student extends Person {
  constructor(options) {
    super(options);
    this.number = options.number;
  }
}
```

#### 意义和解决的问题

- 继承最大的一个好处就是代码复用。如果两类有相同的属性和方法，就可以将它们抽取到父类，并让两个子类继承父类
- 符合人类认知，从代码设计角度来说也是一种结构美感。学生是人，从人类认知角度来说，是一种 is-a 关系，非常符合我们认知。
- 继承很好理解，但是继承层次过审就会导致可读性、可维护性变差。

### 多态

#### 定义

- 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。
- 多态和重载最大的区别在于参数的上，前者参数必须一致，后者可以重载扩展。

```ts
abstract class Person {
  public name: string;
  constructor(options) {
    this.name = options.name
  }
  // 不实现任何代码，子类实现
  abstract say(number: number): void;
}

class Student extends Person {
  public number: number;
  constructor(options) {
    super(options);
    this.number = options.number;
  }

  say(number: number) {
    console.log('学生的编号是' + number);
  }
}

class Teacher extends Person {
  public number: number;
  constructor(options) {
    super(options);
    this.number = options.number;
  }

  say(number: number) {
    console.log('学生的编号是' + number);
  }
}

// 也可以是使用 interface
interface PersonInterface {
  say(number: number): void;
}
class Student implements PersonInterface {
  say(number: number): void {
    // ...
  }
}
```

#### 意义和解决的问题

- 提升代码可维护性复用性（?）
- 是很多设计模式、设计原则的实现基础。例如策略模式、依赖倒置原则等

## 面向对象比面向过程好在哪

### 什么是面向过程编程与面向过程编程语言

#### 面向对象

回归一下前面的内容

- 面向对象编程：就是以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态作为代码设计和实现的基础
- 面向对象编程语言：支持类或对象，并有现场的语法机制，能方便实现四大特性封装、抽象、继承、多态

#### 面向过程

类比一下，我们就可以得出面向过程的定义

- 面向过程编程：也是一种编程范式（风格），它以**过程**（可以理解为方法、函数、操作）作为组织代码的基本单元，以**数据**（可以理解为变量、属性）与方法相分离为主要特点。是一种**流程化**的编程风格，通过拼接一组操作数据完成一项功能。
- 面向过程编程语言：最大特点是**不支持类和对象**两个语法概念，不支持丰富的面向对象特性（比如封装、抽象、继承），仅支持面向过程编程。

#### 区别

它们最基本的区别是代码的组织方式不同

- 面向过程的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。
- 面向对象的代码被组织成一组类，方法和数据结构被绑定在一起。

### 面向对象有哪些优势

面向过程先出现，面向对象为什么能成为主流的编程范式？和面向过程相比到底有什么优势？

- OOP 更加能够应对大规模复杂程序的开发
  - 它们的代码实现其实差不多，只是组织方式不同，一般情况下没有感觉明显的优势！
  - **如果需求足够简单，那么处理流程只有一条线，通过划分成不同的几个步骤，并翻译成代码，这种非常适合面向过程来实现！**
  - 但是如果是大规模的程序开发，整个处理流程并不是一条线而是错综复杂的，是一个网状结构。
    - 如果按照面向过程这种流程化的思维去“翻译”这个网状结构，**去思考如何将程序拆分成一组程序执行的方法，会比较吃力**！
    - 面向对象则是以类为思考对象，先去思考业务如何建模，如何将需求翻译为类，如何给这些类建立交互关系，而完成这些并不需要考虑错综复杂的流程。**有了类的设计之后，就可以像搭积木一样，按照不同流程组装形成整个程序**。
  - 面向对象通过类也提供一种更清晰、更加模块化的代码组织方式。例如我们一个广告系统业务逻辑复杂、代码量很大，数百个函数、数据结构怎么组织才能不凌乱呢？类就是一种很好的方式。当然通过将不同函数、数据结构放到不同的文件（JS 的方式）也可以达到这种效果，但是这并不是强求的，面向对象将强制你这么去做。

- OOP 风格的代码更易复用、易扩展、易维护
  - 封装：面向对象将数据和方法绑定在一起，通过对访问权限的控制，只允许外部调用类暴露的方法有限的访问数据，不向面向过程那些可以任意方法修改，更有利于维护
  - 抽象：我们知道函数本身也是抽象，隐藏了具体的实现。从这一点来说面向过程和面向对象都是支持的，但是面向对象的编程还提供了其他抽象方式，例如基于接口实现的抽象，可以让我们不改变原有实现的情况下轻松替换新的实现逻辑，提高可扩展性
  - 继承：可以将两个类公共的方法，抽取到父类，并让两个字类继承父类，提高代码的复用性
  - 多态：

- OOP 语言更加人性化、更加高级、更加智能
  - 在语言的发展历史中，当使用二进制指令、汇编语言、面向过程编程语言时，我们在思考，如何设计一组指令，告诉机器去执行，操作某些数据，完成我们任务
  - 而面向对象编程时，我们在思考，如何给业务建模，如何将真实世界映射为类或对象，这让我们更聚焦在业务本身，而不是思考如何跟机器打交道。更加人性化、更加高级、更加智能。

### 这些代码看似时面向对象实际是面向过程

不是把所有代码都塞到类里，自然就是进行面向对象编程了。有的代码表面看是面向对象，本质却是面向过程。接下来结合实例分析一下，另外也思考两个问题：为什么我们容易写出这种代码？面向过程是否真的是无用武之地了？

#### 滥用 getter、setter 方法

有时候我们定义属性，就顺手把这些属性的 getter、setter 都定义上。这些方法可能以后会用上，并且也无伤大雅。

```ts
class Person {
  private name: string;
  private age: number;
  private hobbyList: Array<string>;
  
  constructor(options) {
    this.name = options.name;
    // ...
  }
  getName() { return this.name }
  setName(name) { this.name = name }
  getAge() { return this.age }
  setAge(age) { this.age = age }
  getHobby() { return this. hobbyList }
  addHobby(hobby) { this.hobbyList.push(hobby) }
}
```

- 面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部只能通过提供的方法进行访问、修改数据
- 暴露不应该暴露的方法，明显违反面向对象的封装特性，相当于数据没有了访问控制，任何代码都可以访问修改它。`name`、`age` 都是 `private`，但是都定义了 `get`、`set` 导致可以随便修改。
- 没有对返回的数据做任何防范，相当于不做限制。`getHobby` 返回一个 array，这样就可以直接通过 `push`、`pop` 等方法直接进行修改。

#### 滥用全局变量和全局方法

在面向对象编程风格中，数据和方法时通过类来组织的。滥用全局变量和全局方法，会违反这个风格。

常见就是和配置相关的全局常量，和各种方法 Utils，这些方法一般和数据是分离的，是典型的面向过程风格。

- Constants 类

```ts
class Constants {
  static MAX_TOTAL = 50;
  static MIN_IDLE = 20;
  // ...
}
// 实际一般会这么写
export const Config = {
  MAX_TOTAL: 50,
  MIN_IDLE: 20
  // ...
}
```

把程序中所有用到的常量，都集中到这个 Constants 中不是一个好思路：
  - 降低可维护性：所有人都修改这个类，后面找起来费劲，也容易冲突
  - 增加代码编译时间：包含很多变量，依赖它的代码也就会很多。那么每次修改，都导致依赖的文件重新编译，需要更多时间
  - 影响复用性：就算我们只依赖一小部分变量，复用的时候还是需要把整个类引入

改进这个设计有两个思路：

  - 将 Constants 拆分成更加单一的多个类：例如和打包配置相关的、和接口请求相关的
  - 另外一个更好的思路是内聚（看实际是否是多个地方用到了）：不单独设计 Constants，而是哪个类用到某个变量，就把这个变量定义到这个类中，接口调用需要接口请求相关的配置，就把它定义到接口调用中，提高类设计的内聚性和代码复用。