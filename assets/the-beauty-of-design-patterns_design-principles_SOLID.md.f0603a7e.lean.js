import{_ as s,o as n,c as a,a as l,b as p,d as o,e,r as t}from"./app.06cc9021.js";const r=JSON.parse('{"title":"SOLID","description":"","frontmatter":{},"headers":[{"level":2,"title":"单一职责原则 Single Responsibility Principle","slug":"单一职责原则-single-responsibility-principle","link":"#单一职责原则-single-responsibility-principle","children":[{"level":3,"title":"如何理解单一指责原则","slug":"如何理解单一指责原则","link":"#如何理解单一指责原则","children":[]},{"level":3,"title":"怎么判断职责是否单一","slug":"怎么判断职责是否单一","link":"#怎么判断职责是否单一","children":[]},{"level":3,"title":"类的职责是否设计越单一越好","slug":"类的职责是否设计越单一越好","link":"#类的职责是否设计越单一越好","children":[]}]},{"level":2,"title":"开闭原则 Open Closed Principle","slug":"开闭原则-open-closed-principle","link":"#开闭原则-open-closed-principle","children":[{"level":3,"title":"如何理解“对扩展开发、修改关闭”","slug":"如何理解-对扩展开发、修改关闭","link":"#如何理解-对扩展开发、修改关闭","children":[]},{"level":3,"title":"修改代码就意味着违背开闭原则吗","slug":"修改代码就意味着违背开闭原则吗","link":"#修改代码就意味着违背开闭原则吗","children":[]},{"level":3,"title":"如何做到“对扩展开放、修改关闭”","slug":"如何做到-对扩展开放、修改关闭","link":"#如何做到-对扩展开放、修改关闭","children":[]},{"level":3,"title":"如何在项目中灵活应用开闭原则","slug":"如何在项目中灵活应用开闭原则","link":"#如何在项目中灵活应用开闭原则","children":[]}]},{"level":2,"title":"里式替换 Liskov Substitution Principle","slug":"里式替换-liskov-substitution-principle","link":"#里式替换-liskov-substitution-principle","children":[{"level":3,"title":"如何理解“里式替换原则”","slug":"如何理解-里式替换原则","link":"#如何理解-里式替换原则","children":[]},{"level":3,"title":"哪些代码明显违背了 LSP","slug":"哪些代码明显违背了-lsp","link":"#哪些代码明显违背了-lsp","children":[]}]},{"level":2,"title":"接口隔离原则 Interface Segregation Principle","slug":"接口隔离原则-interface-segregation-principle","link":"#接口隔离原则-interface-segregation-principle","children":[{"level":3,"title":"如何理解“接口隔离原则”","slug":"如何理解-接口隔离原则","link":"#如何理解-接口隔离原则","children":[]},{"level":3,"title":"把“接口”理解为一组 API 接口集合","slug":"把-接口-理解为一组-api-接口集合","link":"#把-接口-理解为一组-api-接口集合","children":[]},{"level":3,"title":"把“接口”理解为单个 API 接口或函数","slug":"把-接口-理解为单个-api-接口或函数","link":"#把-接口-理解为单个-api-接口或函数","children":[]},{"level":3,"title":"把“接口”理解为 OOP 中的接口概念","slug":"把-接口-理解为-oop-中的接口概念","link":"#把-接口-理解为-oop-中的接口概念","children":[]}]},{"level":2,"title":"依赖反转原则 Dependency Inversion Principle","slug":"依赖反转原则-dependency-inversion-principle","link":"#依赖反转原则-dependency-inversion-principle","children":[{"level":3,"title":"控制反转（IOC）","slug":"控制反转-ioc","link":"#控制反转-ioc","children":[]},{"level":3,"title":"依赖注入（DI）","slug":"依赖注入-di","link":"#依赖注入-di","children":[]},{"level":3,"title":"依赖注入框架（DI Framework）","slug":"依赖注入框架-di-framework","link":"#依赖注入框架-di-framework","children":[]},{"level":3,"title":"依赖反转原则（DIP）","slug":"依赖反转原则-dip","link":"#依赖反转原则-dip","children":[]}]}],"relativePath":"the-beauty-of-design-patterns/design-principles/SOLID.md"}'),c={name:"the-beauty-of-design-patterns/design-principles/SOLID.md"},y=p("h1",{id:"solid",tabindex:"-1"},[o("SOLID "),p("a",{class:"header-anchor",href:"#solid","aria-hidden":"true"},"#")],-1),F=e("",37),D=e("",163);const C=s(c,[["render",function(s,p,o,e,r,c){const C=t("VueJobs"),A=t("nx-tip");return n(),a("div",null,[y,l(C),F,l(A,{type:"warning",text:"实际上，不管是应用设计原则还是设计模式，最终的目的还是**提高代码的可读性、可扩展性、复用性、可维护性等**。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。"}),D])}]]);export{r as __pageData,C as default};
