import{_ as e,o as a,c as n,a as i,b as s,d as r,e as t,r as o}from"./app.06cc9021.js";const d=JSON.parse('{"title":"YAGNI","description":"","frontmatter":{},"headers":[{"level":3,"title":"如何理解“YAGNI\\"","slug":"如何理解-yagni","link":"#如何理解-yagni","children":[]},{"level":3,"title":"KISS 和 YAGNI 区别","slug":"kiss-和-yagni-区别","link":"#kiss-和-yagni-区别","children":[]}],"relativePath":"the-beauty-of-design-patterns/design-principles/YAGNI.md"}'),l={name:"the-beauty-of-design-patterns/design-principles/YAGNI.md"},p=s("h1",{id:"yagni",tabindex:"-1"},[r("YAGNI "),s("a",{class:"header-anchor",href:"#yagni","aria-hidden":"true"},"#")],-1),g=t('<p>YAGNI 你可能没怎么听过，不过它理解起来也不难。</p><h3 id="如何理解-yagni" tabindex="-1">如何理解“YAGNI&quot; <a class="header-anchor" href="#如何理解-yagni" aria-hidden="true">#</a></h3><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。</p><p>这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：<strong>不要去设计当前用不到的功能；不要去编写当前用不到的代码</strong>。实际上，这条原则的核心思想就是：<strong>不要做过度设计</strong>。</p><p>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。</p><p>当然，这并不是说我们就不需要考虑代码的扩展性。我们<strong>还是要预留好扩展点</strong>，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</p><h3 id="kiss-和-yagni-区别" tabindex="-1">KISS 和 YAGNI 区别 <a class="header-anchor" href="#kiss-和-yagni-区别" aria-hidden="true">#</a></h3><p>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。</p><ul><li>KISS 原则讲的是“<strong>如何做</strong>”的问题（尽量保持简单），</li><li>而 YAGNI 原则说的是“<strong>要不要做</strong>”的问题（当前不需要的就不要做）。</li></ul>',9);const h=e(l,[["render",function(e,s,r,t,d,l){const h=o("VueJobs");return a(),n("div",null,[p,i(h),g])}]]);export{d as __pageData,h as default};
