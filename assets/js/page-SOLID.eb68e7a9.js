(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{506:function(t,s,a){"use strict";a.r(s);var v=a(2),r=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"solid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#solid"}},[t._v("#")]),t._v(" SOLID")]),t._v(" "),a("p",[t._v("接下来，学习一些经典设计原则，介绍这些原则的定义，原则设计的初衷，能解决哪些问题，有哪些应用场景等。")]),t._v(" "),a("p",[t._v("SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。")]),t._v(" "),a("h2",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),a("h3",{attrs:{id:"如何理解单一指责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解单一指责原则"}},[t._v("#")]),t._v(" 如何理解单一指责原则")]),t._v(" "),a("p",[t._v("单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是："),a("strong",[t._v("一个类或者模块只负责完成一个职责（或者功能）")])]),t._v(" "),a("p",[t._v("这个原则的描述对象包含两个：类（class）和模块（module）")]),t._v(" "),a("p",[t._v("关于这个概念有两个理解：")]),t._v(" "),a("ul",[a("li",[t._v("把模块看作是"),a("strong",[t._v("更加抽象的概念")]),t._v("，类也可以看作模块；")]),t._v(" "),a("li",[t._v("把模块看作比类更粗粒度的"),a("strong",[t._v("代码块")]),t._v("，模块包含多个类，多个类组成一个模块。")])]),t._v(" "),a("p",[t._v("接下来只从“类”的角度进行分析。")]),t._v(" "),a("p",[t._v("单一指责定义很简单，也很好理解。一个类只负责完成一个职责或功能，也就是说不要设计大而全的类，要设计粒度小、功能单一的类。如果把两个或两个以上业务不相干的功能放到一个类中，那么我们就可以说它的职责不单一，应该进行拆分。")]),t._v(" "),a("h3",{attrs:{id:"怎么判断职责是否单一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么判断职责是否单一"}},[t._v("#")]),t._v(" 怎么判断职责是否单一")]),t._v(" "),a("p",[t._v("虽然有时我们容易看出两个功能是否想干，但是在大部分真实开发中，对于一个类是否职责单一的判断是很拿捏的。")]),t._v(" "),a("p",[t._v("举个列子")]),t._v(" "),a("h3",{attrs:{id:"类的职责是否设计越单一越好"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的职责是否设计越单一越好"}},[t._v("#")]),t._v(" 类的职责是否设计越单一越好")])])}),[],!1,null,null,null);s.default=r.exports}}]);