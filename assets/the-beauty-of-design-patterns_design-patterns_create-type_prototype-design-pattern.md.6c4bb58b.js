import{_ as t,o as e,c as r,a,b as d,d as s,e as n,r as l}from"./app.7b8c6bb5.js";const p=JSON.parse('{"title":"原型模式","description":"","frontmatter":{},"headers":[{"level":2,"title":"原型模式的原理与应用","slug":"原型模式的原理与应用","link":"#原型模式的原理与应用","children":[{"level":3,"title":"何为创建成本比较大","slug":"何为创建成本比较大","link":"#何为创建成本比较大","children":[]},{"level":3,"title":"通过一个例子来解释一下刚刚这段话","slug":"通过一个例子来解释一下刚刚这段话","link":"#通过一个例子来解释一下刚刚这段话","children":[]}]},{"level":2,"title":"原型模式的实现方式深拷贝和浅拷贝","slug":"原型模式的实现方式深拷贝和浅拷贝","link":"#原型模式的实现方式深拷贝和浅拷贝","children":[{"level":3,"title":"深拷贝浅拷贝的区别","slug":"深拷贝浅拷贝的区别","link":"#深拷贝浅拷贝的区别","children":[]},{"level":3,"title":"实现深拷贝","slug":"实现深拷贝","link":"#实现深拷贝","children":[]}]}],"relativePath":"the-beauty-of-design-patterns/design-patterns/create-type/prototype-design-pattern.md"}'),i={name:"the-beauty-of-design-patterns/design-patterns/create-type/prototype-design-pattern.md"},h=d("h1",{id:"原型模式",tabindex:"-1"},[s("原型模式 "),d("a",{class:"header-anchor",href:"#原型模式","aria-hidden":"true"},"#")],-1),o=n('<p>前面已经介绍了单例模式、工厂模式、建造者模式，今天我们来讲最后一个：原型模式。</p><p>对于前面来说，原型模式是已经比较常用的开发模式，即使现在 es6 引入了 class，但是它也只是基于原型的语法糖。</p><p>接下来不和某一语言语法机制相关，而是通过一个 clone 散列表的例子带你搞清楚：<strong>原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝</strong>。</p><h2 id="原型模式的原理与应用" tabindex="-1">原型模式的原理与应用 <a class="header-anchor" href="#原型模式的原理与应用" aria-hidden="true">#</a></h2><p>如果对象的<strong>创建成本比较大</strong>，而同一个类的<strong>不同对象之间差别不大</strong>（大部分字段都相同），在这种情况下，我们可以利用<strong>对已有对象</strong>（原型）进行<strong>复制</strong>（或者叫拷贝）的方式来创建新对象，以达到<strong>节省创建时间</strong>的目的。这种基于原型来创建对象的方式就叫作<strong>原型设计模式</strong>（Prototype Design Pattern），简称<strong>原型模式</strong>。</p><h3 id="何为创建成本比较大" tabindex="-1">何为创建成本比较大 <a class="header-anchor" href="#何为创建成本比较大" aria-hidden="true">#</a></h3><p>一般，创建对象包括申请内存，给成员变量赋值，这一过程<strong>本身不会花费太多时间</strong>。对于大部分系统来说，这点时间完全可以忽略。使用复杂的模式，只是得到一点点性能的提升，这就是所谓的过度设计，得不偿失。</p><p>但是如果创建对象需要<strong>经过耗时的操作</strong>，例如复杂的计算（例如排序，计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次再创建新的对象，重复执行这些耗时操作。</p><h3 id="通过一个例子来解释一下刚刚这段话" tabindex="-1">通过一个例子来解释一下刚刚这段话 <a class="header-anchor" href="#通过一个例子来解释一下刚刚这段话" aria-hidden="true">#</a></h3><ul><li>需求背景</li></ul><p>假设数据库存储 10w 条“搜索关键词”信息，每条包含关键词、关键词被搜索的次数、信息最近更新的时间。</p><p>v2</p><table><thead><tr><th>关键词</th><th>次数</th><th>更新时间</th></tr></thead><tbody><tr><td>算法</td><td>2033</td><td>1548506764</td></tr><tr><td>设计模式</td><td>7867</td><td>1548506344</td></tr><tr><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>系统 A 在启动的时候会加载这份数据到内存中，用户处理相关业务需求。为了方便快速查找某个关键词对应的信息，给关键词建立一个散列表索引。</p><p>另外，还有一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量的更新数据库的数据，并且标记为最新的数据版本。</p><p>v3</p><table><thead><tr><th>关键词</th><th>次数</th><th>更新时间</th></tr></thead><tbody><tr><td>算法</td><td>2033</td><td>1548506764</td></tr><tr><td>设计模式</td><td><strong>9000</strong></td><td><strong>1548509453</strong></td></tr><tr><td>...</td><td>...</td><td>...</td></tr></tbody></table><ul><li>为了保证系统 A 数据的实时行（不一定非常实时单不能太久），系统 A 需要定期更新数据的数据，更新内存中，怎么实现这个需求？</li></ul><p>只需要在系统 A 中，记录当前数据的版本 V2 对应的更新时间 T2，从数据库中捞出更新时间大于 T2 的所有搜索关键词，也就是找出 V2 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。</p><p>如果已经在散列表中，就更新相应的搜索次数、更新时间等信息；如果它不在散列表中，就将它插入散列表中。</p><ul><li>任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。另外还要求，在更新内存数据的时候，系统 A 不能处于不可用的状态，也就是不能停机更新数据。怎么实现？</li></ul><p>首先，我们把正在使用的数据的版本定义为“服务版本”，然后更新内存中数据的时候，并不是直接在服务版本（v2）上更新，而是重新创建另外一个版本（v3），等新的版本数据建好之后，再一次性地将服务版本从 v2 切换到 v3。</p><p>这样就保证数据一直可用，又避免了中间状态的存在。</p><ul><li>但是重新创建一个版本耗时会很高，需要从数据库中读出这 10w 条数据，然后还需要计算哈希值，构建新的哈希表。怎么解决耗时的问题呢？</li></ul><p>为了提高效率，原型模式就派上用场了。</p><p>我们直接将当前的哈希表<strong>复制到</strong>新的哈希表，然后从数据库捞出新增或者有更新的关键词，更新到新的哈希表中。相对于新建 10w 来说，每次新增/更新的关键词还是比较少的，所以这样就大大提高了数据更新的效率。</p><p>不过这样容易有一个问题，理解这个问题就需要先了解：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）</p><h2 id="原型模式的实现方式深拷贝和浅拷贝" tabindex="-1">原型模式的实现方式深拷贝和浅拷贝 <a class="header-anchor" href="#原型模式的实现方式深拷贝和浅拷贝" aria-hidden="true">#</a></h2><p>内存中，散列表的结构大致如下。散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p><p><img src="/assets/design-patterns-hashmap.88e22c92.png" alt=""></p><h3 id="深拷贝浅拷贝的区别" tabindex="-1">深拷贝浅拷贝的区别 <a class="header-anchor" href="#深拷贝浅拷贝的区别" aria-hidden="true">#</a></h3><p>浅拷贝和深拷贝的区别在于：</p><ul><li>浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象）</li><li>相反，深拷贝不仅仅会复制索引，还会复制数据本身。深拷贝得到的是一份完完全全独立的对象。</li></ul><p><img src="/assets/design-patterns-shallow-copy.9fb0a829.png" alt=""><img src="/assets/design-patterns-deep-copy.dff9238d.png" alt=""></p><p>前面的实现中，将当前哈希表直接复制到新的哈希表。这样当我们去更新新的哈希表中 SearchWord 对象的时候，因为指向的都是一个 SearchWord，就会导致当前哈希表的数据也被更新，也就是当前哈希表同时通常两个版本的数据！</p><p>为了解决这个问题，我们可以将浅拷贝替换为深拷贝。不仅仅复制索引，还把 SearchWord 也复制一份出来。</p><h3 id="实现深拷贝" tabindex="-1">实现深拷贝 <a class="header-anchor" href="#实现深拷贝" aria-hidden="true">#</a></h3><p>如何实现深拷贝呢？总结一下的话，有下面两种方法。</p><ul><li>第一种方法：递归拷贝对象</li></ul><p>递归拷贝对象...，直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。</p><ul><li>第二种方法：先将对象序列化，然后再反序列化成新的对象。</li></ul>',41);const g=t(i,[["render",function(t,d,s,n,p,i){const g=l("VueJobs");return e(),r("div",null,[h,a(g),o])}]]);export{p as __pageData,g as default};
